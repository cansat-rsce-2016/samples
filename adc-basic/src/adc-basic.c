/*
 * adc-basic.c
 *
 * базовый пример использования АЦП
 * АЦП запускается в режиме одиночных измерений и результаты последовательно передаются в UART в виде текста
 */

#include <stdint.h>
#include <stdio.h>

#include <avr/io.h>

void initUartStdio();

int main() {
	// инициализируем UART для передачи значений, полученных с АЦП на компьютер
	// ==================================================
	initUartStdio();

	// Конфигурируем АЦП
	// =============================
	ADMUX = (0 << REFS1) | (1 << REFS0) // опорное напряжение - AVcc (напряжение питания контроллера = 5 Вольт
			| (0 << ADLAR) // выравнивание значения в буфере ADC по правой границе
			| (0 << MUX3) | (0 << MUX2) | (0 << MUX1) | (0 << MUX0) // одиночный канал ADC0
	;

	ADCSRA = (1 << ADEN)   // Включаем модуль АЦП (просто подача питания)
			| (0 << ADSC)  // пока не начинаем преобразование
			| (0 << ADATE)  // используем режим одиночных измерений, без автотриггера
			| (1 << ADIF)  // флаг прерывания изначально сброшен, а сбрасывается он записью в него единцы
			| (0 << ADIE)  // не используем прерывания
			| (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0) // Используем максимальный делитель (128) частоты для модуля АЦП
														 // чтобы обеспечить высокую точность даже на 16МГЦ процессора
	;

	while(1) {

		ADCSRA |= (1 << ADIF); // сбрасываем флаг прерывания (именно записью в него единицы, см документацию)
		ADCSRA |= (1 << ADSC); // запускаем преобразование АЦП

		// ждем окончания преобразования
		while (!(ADCSRA & (1 << ADIF)))
		{}
		// читаем результаты преобразования, Важно читать их именно в таком порядке
		// volatile тут защищает от оптимизаций компилятора, которые могут нарушить порядок чтения
		volatile uint8_t low = ADCL;
		volatile uint8_t high = ADCH;

		// собираем 16тибитное значение
		uint16_t adcValueBuffer = high << 8 | low;

		// формируем текстовое сообщение комьпютеру
		printf("ADC_VALUE: 0x%04X\r\n", adcValueBuffer);
	}

	return 0;
}




static int myPutChar(char value, FILE * stream) {
	(void)stream; // не используем переменную. Таким образом глушим варнинг о неиспользуемой переменной

	while ( !(UCSR0A & (1 << UDRE0)) )
	{}

	UDR0 = value;
	return 0;
}

static int myGetChar(FILE * stream) {
	(void)stream; // не используем переменную. Таким образом глушим варнинг о неиспользуемой переменной

	while ( !(UCSR0A & (1 << RXC0)) )
	{}

	return UDR0;
}


// глобальная переменная stdout
FILE mystdout = FDEV_SETUP_STREAM(myPutChar, NULL, _FDEV_SETUP_WRITE);
FILE mystdin = FDEV_SETUP_STREAM(NULL, myGetChar, _FDEV_SETUP_READ);

void initUartStdio() {
	UCSR0B = (1 << TXEN0) | (1 << RXEN0); // включаем TX RX
	;
	UCSR0C = (1 << UCSZ00) | (1 << UCSZ01) // Размер символа - 8 бит
		| (0 << UPM00) | (0 << UPM01)      // Бит чертности отключен
		| (0 << USBS0) // 1 стоп бит
	;

	// baud на 9600 по таблице на частоте в 16мгц
	UBRR0H = 103 / 0xFF;
	UBRR0L = 103 % 0xFF;

	stdout = &mystdout;
	stdin = &mystdin;
}
