/*
 * adc-basic.c
 *
 *  Created on: 16 дек. 2015 г.
 *      Author: snork
 */


/*
 * adc-example.c
 *
 * Пример использования АЦП
 */

#include <stdint.h>
#include <stdio.h>

#include <avr/io.h>


// Инициалазция UART0 для передачи данных с АЦП в терминал
// baud rate 9600; parity: none; stop bits: one
// подразумевается, что контроллер запущен на 16 МГЦ
void initUart() {
    UCSR0B = (1 << TXEN0)  // включаем только TX
    ;
    UCSR0C = (1 << UCSZ00) | (1 << UCSZ01) // Размер символа - 8 бит
        | (0 << UPM00) | (0 << UPM01)      // Бит чертности отключен
        | (0 << USBS0) // 1 стоп бит
    ;

    // baud на 9600 по таблице на частоте в 16мгц
    UBRR0H = 103 / 0xFF;
    UBRR0L = 103 % 0xFF;
}


void uartWrite(const char * message) {
    // цикл по каждому байту сообщений message, пока не встретим нулевой, что будет означать конец сообщения
    for ( ; *message != 0; message++) {
        while (!(UCSR0A & (1 << UDRE0))) // ждем, пока предыущий байт не покинет буфер
        {}

        UDR0 = *message; // передаем текущий байт в буффер
    }
}



int main() {

    // Конфигурируем АЦП
    // =============================

    ADMUX = (0 << REFS1) | (1 << REFS0) // опорное напряжение - AVcc (напряжение питания контроллера = 5 Вольт
            | (0 << ADLAR) // выравнивание значения в буфере ADC по правой границе
            | (0 << MUX3) | (0 << MUX2) | (0 << MUX1) | (0 << MUX0) // одиночный канал ADC0
    ;

    ADCSRA = (1 << ADEN)   // Включаем модуль АЦП (просто подача питания)
            | (0 << ADSC)  // пока не начинаем преобразование
            | (0 << ADEN)  // используем режим одиночных измерений, без автотриггера
            | (1 << ADIF)  // флаг прерывания изначально сброшен, а сбрасывается он записью в него единцы
            | (0 << ADIE)  // не используем прерывания
            | (1 << ADPS1) | (1 << ADPS1) | (1 << ADPS0) // Используем максимальный делитель (128) частоты для модуля АЦП
                                                         // чтобы обеспечить высокую точность даже на 16МГЦ процессора
    ;


    // инициализируем UART для передачи значений, полученных с АЦП на компьютер
    // ==================================================
    initUart();

    DDRB |= (1 << 5);

    while(1) {

        ADCSRA |= (1 << ADIF); // сбрасываем флаг прерывания (именно записью в него единицы, см документацию)
        ADCSRA |= (1 << ADSC); // запускаем преобразование АЦП

        // ждем окончания преобразования
        while (!(ADCSRA & (1 << ADIF)))
        {}
        // читаем результаты преобразования, Важно читать их именно в таком порядке
        // volatile тут защищает от оптимизаций компилятора, которые могут нарушить порядок чтения
        volatile uint8_t low = ADCL;
        volatile uint8_t high = ADCH;

        // собираем 16тибитное значение
        uint16_t adcValueBuffer = high << 8 | low;

        // формируем текстовое сообщение комьпютеру
        char buffer[100] = {0x00}; // инициализируем буффер нулями, чтобы конец сообщения был четко определим
        sprintf(buffer, "ADC_VALUE: 0x%X\r\n", adcValueBuffer);
        uartWrite(buffer);
    }

    return 0;
}
